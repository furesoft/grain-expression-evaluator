module Evaluator

from "./parsing.gr" include Parser
from "./tree.gr" include Tree
from "map" include Map
from "./scope.gr" include Scope
from "array" include Array

use Map.*
use Scope.*

let rootScope = Scope.make()

Scope.setVariable("pi", 3.14, rootScope)

let rec visit = (tree, scope) => {
    match(tree) {
        Tree.NumberExpression(num) => num,
        Tree.GroupExpression(inner) => visit(inner, scope),
        Tree.BinaryExpression(left, op, right) => visitBinary(left, op, right, scope),
        Tree.VariableReferenceExpression(id) => visitVariableRef(id, scope),
        Tree.FunctionCallExpression(name, args) => visitFunctionCall(name, args, scope),
        _ => 0
    }
}
and visitFunctionCall = (name, args, scope) => {
    // ToDo: implement function call for custom defined functions
    match(Scope.getFunction(name, rootScope)) {
        Some(callback) => callback(args),
        None => fail("function " ++ name ++ " not found")
    }
}
and visitBinary = (left, op, right, scope) => {
    if(op == "=") {
        return visitVariableBinding(left, right, scope)
    }

    let evaluatedLeft = visit(left, scope)
    let evaluatedRight = visit(right, scope)

    return match(op) {
        "+" => evaluatedLeft + evaluatedRight,
        "-" => evaluatedLeft - evaluatedRight,
        "*" => evaluatedLeft * evaluatedRight,
        "/" => evaluatedLeft / evaluatedRight,
        _ => 0
    }
}
and visitVariableRef = (id, scope) => {
    match(Scope.getVariable(id, scope)) {
        Some(value) => value,
        None => fail("Variable " ++ id ++ " not found")
    }
}
and visitVariableBinding = (name, value, scope) => {
    match(name) {
        Tree.VariableReferenceExpression(id) => {
            let visitedValue = visit(value, scope)
            Scope.setVariable(id, visitedValue, scope)

            visitedValue
        },
        Tree.FunctionCallExpression(name, args) => {
            Scope.setFunction(name, (a) => {
               42
            }, scope)
            0
        },
        _ => 0
    }
}

provide let eval = (input) => {
    let tree = Parser.parse(input)

    visit(tree, rootScope)
}

Scope.setFunction("power", (args) => {
    let scope = Scope.fromParent(rootScope)
    let base = visit(args[0], scope)
    let exponent = visit(args[1], scope)

    base ** exponent
}, rootScope)
