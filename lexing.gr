module Lexing

from "buffer" include Buffer
from "string" include String
from "list" include List
from "char" include Char


record LexingState {
  mut position: Number,
  input: String
}

provide enum rec TokenType {
    Plus,
    Minus,
    Asterisk,
    Slash,
    Number,
    EndOfInput,
    Invalid
}

provide record Token {
  text: String,
  kind: TokenType
}

provide enum LexingError {
  UnexpectedEndOfInput,
  UnkownChar(Char)
}

let isEndOfInput = state => state.position >= String.length(state.input)

let nextChar = (state) => {
  state.position += 1
  print(state.position)

  if (state.position >= String.length(state.input)) {
    Err(UnexpectedEndOfInput)
  } else {
    Ok(String.charAt(state.position, state.input))
  }
}

let buffer = Buffer.make(256)

let nextToken = state => {
  Buffer.clear(buffer)

  if(isEndOfInput(state)) {
    return Ok({ text: "", kind: EndOfInput })
  }

  let char = match (nextChar(state)) {
    Ok(c) => c,
    Err(e) => return Err(e)
  }

  if(Char.isAsciiDigit(char)) {
    while(Char.isAsciiDigit(char)) {
      let char = match (nextChar(state)) {
        Ok(c) => c,
        Err(e) => return Err(e)
      }

      Buffer.addChar(char, buffer)
    }

    return Ok({ text: Buffer.toString(buffer), kind: Number })
  }

  return Err(UnkownChar(char))
}


provide let lex = input => {
  let state = {
    position: -1,
    input: input
  }

  let tokens = []

  while(!isEndOfInput(state)) {
    match(nextToken(state)) {
      Ok(token) => List.append(token, tokens),
      Err(err) => print(err)
    }
  }

  return tokens
}

