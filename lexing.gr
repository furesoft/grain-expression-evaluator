module Lexing

from "buffer" include Buffer
from "string" include String
from "list" include List
from "char" include Char
from "result" include Result


provide record LexingState {
  mut position: Number,
  input: String
}

provide enum rec TokenType {
    Plus,
    Minus,
    Asterisk,
    Slash,
    Number,
    EndOfInput,
    Invalid
}

provide record Token {
  text: String,
  kind: TokenType
}

provide enum LexingError {
  UnexpectedEndOfInput,
  UnkownChar(Char)
}

let isEndOfInput = state => state.position >= String.length(state.input)

let nextChar = (state) => {
  while (state.position < String.length(state.input)) {
    let c = String.charAt(state.position, state.input)

    state.position += 1
    if(c == ' ') {
      continue;
    }

    return c
  }

  return '\0'
}

let buffer = Buffer.make(256)

let tokenFromChar = (char, kind) => Ok({ text: Char.toString(char), kind: kind })

provide let nextToken = state => {
  Buffer.clear(buffer)

  let mut char = nextChar(state)

  if(char == '\0') {
    return tokenFromChar(char, EndOfInput)
  }
  
  if(char == '+') {
    state.position += 1

    return tokenFromChar(char, Plus)
  }

  if(char == '*') {
    state.position += 1
    return tokenFromChar(char, Asterisk)
  }

  if(char == '1') {
    state.position += 1
    return tokenFromChar(char, Number)
  }

  if(char == '2') {
    state.position += 1
    return tokenFromChar(char, Number)
  }

  if(char == '3') {
    state.position += 1
    return tokenFromChar(char, Number)
  }

  /**/
  if(char == '+') {
    state.position += 1
    return tokenFromChar(char, Plus)
  }
  else if(char == '*') {
    state.position += 1
    return tokenFromChar(char, Asterisk)
  }
  else if(Char.isAsciiDigit(char)) {
    while(Char.isAsciiDigit(char)) {
      char = nextChar(state)

      Buffer.addChar(char, buffer)
    }

    return Ok({ text: Buffer.toString(buffer), kind: Number })
  }
  */
  
  return Err(UnkownChar(char))
}


