module Lexing

from "buffer" include Buffer
from "string" include String
from "list" include List
from "char" include Char
from "result" include Result


record LexingState {
  mut position: Number,
  input: String
}

provide enum rec TokenType {
    Plus,
    Minus,
    Asterisk,
    Slash,
    Number,
    EndOfInput,
    Invalid
}

provide record Token {
  text: String,
  kind: TokenType
}

provide enum LexingError {
  UnexpectedEndOfInput,
  UnkownChar(Char)
}

let isEndOfInput = state => state.position >= String.length(state.input)

let nextChar = (state) => {
  state.position += 1
  
  if (state.position >= String.length(state.input)) {
    Err(UnexpectedEndOfInput)
  } else {
    Ok(String.charAt(state.position, state.input))
  }
}

let buffer = Buffer.make(256)

let skipWhitespace = state => {
  let char = Result.unwrap(nextChar(state))

  print(state)
  while(char == ' ') {
    state.position += 1
  }

}

let nextToken = state => {
  Buffer.clear(buffer)

  let mut char = match (nextChar(state)) {
    Ok(c) => c,
    Err(e) => return Ok({ text: "", kind: EndOfInput })
  }

  if(char == '+') {
    return Ok({ text: Char.toString(char), kind: Plus })
  }
  else if(char == '*') {
    return Ok({ text: Char.toString(char), kind: Asterisk })
  }
  else if(Char.isAsciiDigit(char)) {
    while(Char.isAsciiDigit(char)) {
      char = match (nextChar(state)) {
        Ok(c) => c,
        Err(e) => return Err(e)
      }

      Buffer.addChar(char, buffer)
    }

    return Ok({ text: Buffer.toString(buffer), kind: Number })
  }

  return Err(UnkownChar(char))
}


provide let lex = input => {
  let state = {
    position: -1,
    input: input
  }

  let mut tokens = []

  while(!isEndOfInput(state)) {
    match(nextToken(state)) {
      Ok(token) => tokens = List.insert(0, token, tokens),
      Err(err) => print(err)
    }
  }

  return Ok(List.reverse(tokens))
}

