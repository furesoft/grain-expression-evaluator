module Parser

from "./tree.gr" include Tree
from "./lexing.gr" include Lexing
from "number" include Number
from "array" include Array
from "list" include List

provide record ParsingState {
    mut currentToken: Lexing.Token,
    mut nextToken: Lexing.Token,
    lexerState: Lexing.LexingState
}

let init = (input) => {
    {
        currentToken: Lexing.emptyToken,
        nextToken: Lexing.emptyToken,
        lexerState: {
            position: 0,
            input: input
        }
    }
}

let nextToken = (state) => {
    state.currentToken = state.nextToken
    state.nextToken = Lexing.nextToken(state.lexerState)

    return state.currentToken
}


let consume = (state, kind) => {
    if(state.nextToken.kind == kind) {
       nextToken(state)
    }
    else {
        Lexing.emptyToken
    }
}

/*
* consumes the token if token kind is the same
*/
let expects = (state, kind) => {
    if(state.nextToken.kind == kind) {
        nextToken(state)

        true
    }
    else {
        false
    }
}

let matches = (state, kind) => {
    state.nextToken.kind == kind
}


let rec parseFactor = (state) => {
    if(expects(state, OpenParen)) {
        let inner = parseExpression(state)
        consume(state, CloseParen)

        Tree.GroupExpression(inner)
    }
    else if(matches(state, Identifier)) {
        let identifier = consume(state, Identifier).text;

        if(matches(state, OpenParen)) {
            parseFunctionCall(state)
        } else {
            Tree.VariableReferenceExpression(identifier)
        }
    }
    else {
        parseAtom(state)
    }
}
and parseAtom = state => {
    let mut token = nextToken(state)

    if(token.kind == Minus) {
        consume(state, Minus)
        let expr = parseExpression(state)

        return Tree.PreUnaryExpression("-", expr)
    }
    else if(token.kind == Pipe) {
        let inner = parseExpression(state)
        consume(state, Pipe)

        return Tree.AbsExpr(inner)
    }
    else if(token.kind == Number) {
        return match(Number.parse(token.text)) {
            Ok(number) => Tree.NumberExpression(number),
            Err(err) => Tree.Invalid()
        }
    }
    else {
        return Tree.Invalid()
    }
}
and parseFunctionCall = (state) => {
    let name = state.currentToken.text;
    let mut args = [>]

    if(expects(state, OpenParen)) {
        args = Array.fromList(parseArgumentList(state))
    }

    return Tree.FunctionCallExpression(name, args)
} and parseArgumentList = (state) => {
    let mut args = []

    while(state.nextToken.kind != CloseParen) {
        args = [parseExpression(state), ...args]

        if(state.nextToken.kind != CloseParen) {
            expects(state, Comma)
            continue
        }
    }
    expects(state, CloseParen)

    List.reverse(args)
}

and parseTerm = (state) => {
    let left = parseFactor(state);

    if(expects(state, Asterisk)) {
        return Tree.BinaryExpression(left, "*", parseTerm(state))
    }
    else if(expects(state, Slash)) {
        return Tree.BinaryExpression(left, "/", parseTerm(state))
    }

    return left;
}
and parseAdditive = (state) => {
    let left = parseTerm(state);

    if(expects(state, Plus)) {
        return Tree.BinaryExpression(left, "+", parseExpression(state))
    }
    else if(expects(state, Minus)) {
        return Tree.BinaryExpression(left, "-", parseExpression(state))
    }
    else if(expects(state, Less)) {
        return Tree.BinaryExpression(left, "<", parseExpression(state))
    }
    else if(expects(state, Greater)) {
        return Tree.BinaryExpression(left, ">", parseExpression(state))
    }
    else if(expects(state, EqualsEquals)) {
        return Tree.BinaryExpression(left, "==", parseExpression(state))
    }
    else if(expects(state, AmpersandAmpersand)) {
        return Tree.BinaryExpression(left, "&&", parseExpression(state))
    }
    else if(expects(state, PipePipe)) {
        return Tree.BinaryExpression(left, "||", parseExpression(state))
    }

    return left;
}
and parseExpression = (state) => {
    let left = parseAdditive(state);

    if(expects(state, Equals)) {
        return Tree.BinaryExpression(left, "=", parseExpression(state))
    }

    return left;
}


provide let parse = input => {
    let state = init(input)
    nextToken(state)

    parseExpression(state)
}
