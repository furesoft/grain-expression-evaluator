module Parser

from "./tree.gr" include Tree
from "./lexing.gr" include Lexing
from "number" include Number

provide record ParsingState {
    mut currentToken: Lexing.Token,
    mut nextToken: Lexing.Token,
    lexerState: Lexing.LexingState
}

let init = (input) => {
    {
        currentToken: Lexing.emptyToken,
        nextToken: Lexing.emptyToken,
        lexerState: {
            position: 0,
            input: input
        }
    }
}

let nextToken = (state) => {
    state.currentToken = state.nextToken
    state.nextToken = Lexing.nextToken(state.lexerState)

    return state.currentToken
}


let parseAtom = state => {
    let mut token = nextToken(state)

    match(Number.parse(token.text)) {
        Ok(number) => Tree.NumberExpression(number),
        Err(err) => Tree.Invalid()
    }
}

let consume = (state, kind) => {
    if(state.nextToken.kind == kind) {
       nextToken(state)
    }
    else {
        Lexing.emptyToken
    }
}

//consumes the token if token kind is the same
let expects = (state, kind) => {
    if(state.nextToken.kind == kind) {
        nextToken(state)

        true
    }
    else {
        false
    }
}

let matches = (state, kind) => {
    state.nextToken.kind == kind
}

let rec parseFactor = (state) => {
    if(expects(state, OpenParen)) {
        let inner = parseExpression(state)
        consume(state, CloseParen)

        return Tree.GroupExpression(inner)
    }
    else if(matches(state, Identifier)) {
        return Tree.VariableReferenceExpression(consume(state, Identifier).text)
    }
    else {
        return parseAtom(state)
    }
}

and parseTerm = (state) => {
    let left = parseFactor(state);

    if(expects(state, Asterisk)) {
        return Tree.BinaryExpression(left, "*", parseTerm(state))
    }
    else if(expects(state, Slash)) {
        return Tree.BinaryExpression(left, "/", parseTerm(state))
    }

    return left;
}
and parseAdditive = (state) => {
    let left = parseTerm(state);

    if(expects(state, Plus)) {
        return Tree.BinaryExpression(left, "+", parseExpression(state))
    }
    else if(expects(state, Minus)) {
        return Tree.BinaryExpression(left, "-", parseExpression(state))
    }

    return left;
}
and parseExpression = (state) => {
    let left = parseAdditive(state);

    if(expects(state, Equals)) {
        return Tree.BinaryExpression(left, "=", parseExpression(state))
    }

    return left;
}


provide let parse = input => {
    let state = init(input)
    nextToken(state)

    parseExpression(state)
}
